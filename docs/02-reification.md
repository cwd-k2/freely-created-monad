# è¨ˆç®—ã®å…·è±¡åŒ–

ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå‘½ä»¤ã‚’è­˜åˆ¥ã—ã¦å‡¦ç†ã‚’åˆ†å²ã™ã‚‹ã«ã¯ã€ã€Œã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ä»Šã©ã‚“ãªå‘½ä»¤ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ã€ãŒå¤–ã‹ã‚‰è¦‹ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã¨ã“ã‚ãŒé€šå¸¸ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ï¼ˆã€Œæ¬¡ã«ä½•ã‚’ã™ã‚‹ã‹ã€ï¼‰ã¯æš—é»™çš„ã§ã€å¤–ã‹ã‚‰è¦—ãã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚

ã“ã®ç« ã§ã¯ã€åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã‚’**ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦è¦‹ãˆã‚‹å½¢ã«ã™ã‚‹**ï¼ˆè¨ˆç®—ã‚’**å…·è±¡åŒ–**ã™ã‚‹ï¼‰ãŸã‚ã®2ã¤ã®æŠ€æ³•ã‚’å°Žå…¥ã—ã¾ã™ã€‚ã€Œæ®‹ã‚Šã®è¨ˆç®—ã€ã‚’å€¤ã¨ã—ã¦æ˜Žç¤ºåŒ–ã™ã‚‹ **CPS** ã¨ã€é–¢æ•°ã‚’ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã™ã‚‹ **Defunctionalization** ã§ã™ã€‚

## CPS: æ®‹ã‚Šã®è¨ˆç®—ã‚’æ˜Žç¤ºåŒ–ã™ã‚‹

### ç›´æŽ¥ã‚¹ã‚¿ã‚¤ãƒ«ã¨ CPS

é€šå¸¸ã€é–¢æ•°ã¯è¨ˆç®—çµæžœã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ï¼ˆç›´æŽ¥ã‚¹ã‚¿ã‚¤ãƒ«ï¼‰ã€‚

```haskell
add :: Int -> Int -> Int
add x y = x + y

square :: Int -> Int
square x = x * x

-- (3 + 4)^2
directExample = square (add 3 4)
```

**CPSï¼ˆContinuation-Passing Styleï¼‰** ã§ã¯ã€ã€Œè¨ˆç®—çµæžœã‚’ã©ã†ã™ã‚‹ã‹ã€ã‚’å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚Šã¾ã™ã€‚

```haskell
addCPS :: Int -> Int -> (Int -> r) -> r
addCPS x y k = k (x + y)

squareCPS :: Int -> (Int -> r) -> r
squareCPS x k = k (x * x)
```

`k` ãŒ **ç¶™ç¶šï¼ˆcontinuationï¼‰** ã§ã™ã€‚ã€Œã“ã®è¨ˆç®—ã®å¾Œã«ã‚„ã‚‹ã“ã¨ã€ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚

```haskell
-- (3 + 4)^2 ã‚’ CPS ã§
cpsExample = addCPS 3 4 (\n -> squareCPS n (\result -> result))
```

### CPS ã®åˆæˆ

CPS è¨ˆç®—ã«ã¯å…±é€šã®åž‹ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒã‚ã‚Šã¾ã™ã€‚

```haskell
type Cont r a = (a -> r) -> r
```

ã€Œ`a` åž‹ã®å€¤ã‚’ç”Ÿã¿å‡ºã™è¨ˆç®—ã§ã€ãã®å€¤ã®ä½¿ã„æ–¹ï¼ˆ`a -> r`ï¼‰ã‚’å—ã‘å–ã£ã¦æœ€çµ‚çµæžœ `r` ã‚’è¿”ã™ã€ã¨èª­ã‚ã¾ã™ã€‚

ã“ã®åž‹ã«å¯¾ã—ã¦ã€è¨ˆç®—ã‚’é€£éŽ–ã•ã›ã‚‹é–¢æ•°ãŒè‡ªç„¶ã«å®šç¾©ã§ãã¾ã™ã€‚

```haskell
bindCont :: Cont r a -> (a -> Cont r b) -> Cont r b
bindCont m f = \k -> m (\a -> f a k)
```

`bindCont` ã¯ã€Œæœ€åˆã®è¨ˆç®— `m` ã‚’å®Ÿè¡Œã—ã€ãã®çµæžœ `a` ã‚’ä½¿ã£ã¦æ¬¡ã®è¨ˆç®— `f a` ã‚’å®Ÿè¡Œã—ã€æœ€çµ‚çš„ãªç¶™ç¶š `k` ã«æ¸¡ã™ã€ã¨ã„ã†æ„å‘³ã§ã™ã€‚ã“ã®**è¨ˆç®—ã‚’éŽ–ã®ã‚ˆã†ã«ç¹‹ã’ã‚‹**æ“ä½œã“ããŒã€å¾Œã«ç™»å ´ã™ã‚‹ãƒ¢ãƒŠãƒ‰ã® `>>=`ï¼ˆbindï¼‰ã®åŽŸåž‹ã§ã‚ã‚Šã€æœ¬è³‡æ–™å…¨ä½“ã‚’è²«ãä¸­å¿ƒçš„ãªã‚¢ã‚¤ãƒ‡ã‚¢ã§ã™ã€‚

### ç¶™ç¶šãŒã‚‚ãŸã‚‰ã™ã‚‚ã® â€” å…·è±¡åŒ–ã®ç¬¬ä¸€æ®µéšŽ

CPS ã«å¤‰æ›ã™ã‚‹ã¨ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã€Œæ®‹ã‚Šã®è¨ˆç®—ã€ãŒ**é–¢æ•°ã¨ã—ã¦æ˜Žç¤ºåŒ–**ã•ã‚Œã¾ã™ã€‚ã“ã‚ŒãŒè¨ˆç®—ã®**å…·è±¡åŒ–ã®ç¬¬ä¸€æ®µéšŽ**ã§ã™ã€‚ç›´æŽ¥ã‚¹ã‚¿ã‚¤ãƒ«ã§ã¯æš—é»™ã ã£ãŸã€Œæ®‹ã‚Šã®è¨ˆç®—ã€ãŒå€¤ã¨ã—ã¦æ‰‹å…ƒã«ã‚ã‚‹ã®ã§ã€ä¿å­˜ã—ã¦å¾Œã§å‘¼ã³å‡ºã™ï¼ˆä¸­æ–­ã¨å†é–‹ï¼‰ã“ã¨ã‚‚ã€`bindCont` ã§ä½“ç³»çš„ã«åˆæˆã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

ãŸã ã— CPS ã§ã¯ç¶™ç¶šã¯**é–¢æ•°**ã§ã™ã€‚é–¢æ•°ã¯å‘¼ã¶ã“ã¨ã—ã‹ã§ããšã€ã€Œã“ã®è¨ˆç®—ã¯ä½•ã‚’ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ã€ã‚’å¤–ã‹ã‚‰è¦‹ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚å‰ç« ã§æŽ²ã’ãŸã€Œå®Ÿè¡Œæ–¹æ³•ã‚’å¾Œã‹ã‚‰å·®ã—æ›¿ãˆã‚‰ã‚Œã‚‹ã€DSL ã‚’å®Ÿç¾ã™ã‚‹ã«ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå‘½ä»¤ã®ç¨®é¡žã‚’è­˜åˆ¥ã—ã¦å‡¦ç†ã‚’åˆ†å²ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å…·è±¡åŒ–ã‚’å®Œæˆã•ã›ã‚‹ã«ã¯ã€ç¶™ç¶šã‚’é–¢æ•°ã®ã¾ã¾æŒã¤ã®ã§ã¯ãªãã€**ãƒ‡ãƒ¼ã‚¿**ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

> ðŸ“– å¯¾å¿œã‚³ãƒ¼ãƒ‰: [`haskell/src/Continuation.hs`](../haskell/src/Continuation.hs)

## Defunctionalization: é–¢æ•°ã‚’ãƒ‡ãƒ¼ã‚¿ã«ã™ã‚‹

**Defunctionalization** ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸­ã®**é–¢æ•°å€¤**ã‚’ãƒ‡ãƒ¼ã‚¿åž‹ã«å¤‰æ›ã™ã‚‹æ‰‹æ³•ã§ã™ã€‚

å¤‰æ›å¯¾è±¡ã¯é–¢æ•°å€¤ãã®ã‚‚ã®ã§ã™ã€‚é«˜éšŽé–¢æ•°ï¼ˆé–¢æ•°ã‚’å¼•æ•°ã«å–ã‚‹é–¢æ•°ï¼‰ã¯é–¢æ•°å€¤ã®*æ¶ˆè²»è€…*ã§ã‚ã‚Šã€Defunctionalization ã¯æ¶ˆè²»è€…ã§ã¯ãªãã€æ¶ˆè²»ã•ã‚Œã‚‹å´ã®é–¢æ•°å€¤ã‚’ãƒ‡ãƒ¼ã‚¿ã«ç½®ãæ›ãˆã¾ã™ã€‚

å…ƒã®é«˜éšŽé–¢æ•°ç‰ˆï¼š

```haskell
applyTwiceHO :: (a -> a) -> a -> a
applyTwiceHO f x = f (f x)

-- ä½¿ç”¨ä¾‹
applyTwiceHO (+3) 10  -- 16
```

Defunctionalization ã®æ‰‹é †ï¼š

**1. ä½¿ã‚ã‚Œã‚‹é–¢æ•°ã‚’ãƒ‡ãƒ¼ã‚¿ã§è¡¨ç¾ã™ã‚‹**

```haskell
data IntFun
  = AddN Int       -- (+n)
  | MulN Int       -- (*n)
  | Square         -- (^2)
```

**2. ãƒ‡ãƒ¼ã‚¿ã‚’é–¢æ•°ã«æˆ»ã™ `apply` ã‚’å®šç¾©ã™ã‚‹**

```haskell
applyIntFun :: IntFun -> Int -> Int
applyIntFun (AddN n) x = x + n
applyIntFun (MulN n) x = x * n
applyIntFun Square   x = x * x
```

**3. é«˜éšŽé–¢æ•°ã‚’ãƒ‡ãƒ¼ã‚¿ç‰ˆã§æ›¸ãç›´ã™**

```haskell
applyTwiceDefunc :: IntFun -> Int -> Int
applyTwiceDefunc fun x = applyIntFun fun (applyIntFun fun x)

applyTwiceDefunc (AddN 3) 10  -- 16
```

é–¢æ•°ãŒãƒ‡ãƒ¼ã‚¿ã«ãªã£ãŸã“ã¨ã§ã€**ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒã«ã‚ˆã‚‹è­˜åˆ¥ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã€æ¯”è¼ƒã€å¤‰æ›ã€æœ€é©åŒ–** ãªã©ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚DSL ã®æ–‡è„ˆã§ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå‘½ä»¤ã‚’ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒã§è­˜åˆ¥ã—ã€å‘½ä»¤ã”ã¨ã«ç•°ãªã‚‹å‡¦ç†ã‚’è¡Œãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã“ã¨ãŒæœ€ã‚‚é‡è¦ãªåˆ©ç‚¹ã§ã™ã€‚

### TypeScript ã§è€ƒãˆã‚‹

TypeScript ãƒ—ãƒ­ã‚°ãƒ©ãƒžã«ã¨ã£ã¦ã€Defunctionalization ã¯é¦´æŸ“ã¿ã®ã‚ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚

```typescript
// é«˜éšŽé–¢æ•°ç‰ˆ
const applyTwice = (f: (x: number) => number, x: number) => f(f(x));

// Defunctionalized ç‰ˆ â€” ã¾ã•ã« union type + switch
type IntFun = { tag: "addN"; n: number } | { tag: "mulN"; n: number } | { tag: "square" };

const applyIntFun = (fun: IntFun, x: number): number => {
  switch (fun.tag) {
    case "addN":  return x + fun.n;
    case "mulN":  return x * fun.n;
    case "square": return x * x;
  }
};
```

ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ tagged union ã«ç½®ãæ›ãˆã‚‹ã€‚ã“ã‚ŒãŒ Defunctionalization ã§ã™ã€‚

> ðŸ“– å¯¾å¿œã‚³ãƒ¼ãƒ‰: [`haskell/src/Defunctionalization.hs`](../haskell/src/Defunctionalization.hs)

## ç¶™ç¶šã® Defunctionalization

å‰ç¯€ã§è¦‹ãŸ CPS ã®ç¶™ç¶šã‚‚é–¢æ•°ã§ã™ã€‚DSL ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå‘½ä»¤ã‚’è­˜åˆ¥ã—ã¦å‡¦ç†ã‚’åˆ†å²ã™ã‚‹ã«ã¯ã€å‘½ä»¤ãŒãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦è¦‹ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã“ã§ã¯ã€ç¶™ç¶šã«å«ã¾ã‚Œã‚‹ã€Œä½•ã‚’ã™ã‚‹ã‹ã€ã®éƒ¨åˆ†ã‚’ãƒ‡ãƒ¼ã‚¿åŒ–ã—ã¦ã„ãã¾ã™ã€‚

```haskell
-- ã€Œä½•ã‚’ã™ã‚‹ã‹ã€ã‚’ãƒ‡ãƒ¼ã‚¿ã§è¡¨ã™
data ContData
  = ThenSquare          -- æ¬¡ã«äºŒä¹—ã™ã‚‹
  | ThenAdd Int         -- æ¬¡ã« n ã‚’è¶³ã™
  | Done                -- ä½•ã‚‚ã—ãªã„

-- ãƒ‡ãƒ¼ã‚¿ã‚’é–¢æ•°ã«æˆ»ã™
applyCont :: ContData -> Int -> Int
applyCont ThenSquare x = x * x
applyCont (ThenAdd n) x = x + n
applyCont Done       x = x
```

ãŸã ã—ç¶™ç¶šã‚’**é€£éŽ–**ã•ã›ãŸã„å ´åˆã€é€”ä¸­ã®ã‚¹ãƒ†ãƒƒãƒ—ã«ã¯ã¾ã é–¢æ•°ãŒæ®‹ã‚Šã¾ã™ã€‚

```haskell
data ContChain a
  = DoneChain
  | forall b. StepChain (a -> b) (ContChain b)
```

> **å­˜åœ¨é‡åŒ–**: Haskell ã® `forall b.` ã¯é€šå¸¸ã¯å…¨ç§°é‡åŒ–ã§ã™ãŒã€**ãƒ‡ãƒ¼ã‚¿æ§‹ç¯‰å­ã®ä¸­**ã«æ›¸ãã¨å­˜åœ¨é‡åŒ–ã¨ã—ã¦åƒãã¾ã™ã€‚`StepChain` ã‚’æ§‹ç¯‰ã™ã‚‹å´ã¯ `b` ã‚’å…·ä½“çš„ã«é¸ã¹ã¾ã™ãŒã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒã§å—ã‘å–ã‚‹å´ã«ã¯ `b` ãŒä½•ã§ã‚ã‚‹ã‹åˆ†ã‹ã‚Šã¾ã›ã‚“ã€‚å¤–ã‹ã‚‰ã¯ `b` ã®å…·ä½“çš„ãªåž‹ã«ä¾å­˜ã™ã‚‹æ“ä½œãŒã§ããªã„ã€ã¨ã„ã†ã“ã¨ã§ã™ï¼ˆch04 ã§å†ã³ç™»å ´ã—ã¾ã™ï¼‰ã€‚

`ContChain` ã¯ã€`bindCont` ã§ç¶™ç¶šã‚’é€£éŽ–ã•ã›ã‚‹ã¨ãã®æ§‹é€ ï¼ˆã€Œå€¤ã‚’å—ã‘å–ã‚Šæ¬¡ã®è¨ˆç®—ã‚’è¡Œã†ã€é–¢æ•°ã®ãƒã‚§ãƒ¼ãƒ³ï¼‰ã‚’ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿æŒã—ã‚ˆã†ã¨ã—ãŸåž‹ã§ã™ã€‚ã¨ã“ã‚ãŒ `StepChain` ã®ä¸­é–“åž‹ `b` ã¯å­˜åœ¨é‡åŒ–ã§éš è”½ã•ã‚Œã‚‹ãŸã‚ã€**å¤–ã‹ã‚‰ã¯ã“ã®ãƒã‚§ãƒ¼ãƒ³ã®æœ€çµ‚çµæžœã‚’å–ã‚Šå‡ºã™åž‹å®‰å…¨ãªæ–¹æ³•ãŒã‚ã‚Šã¾ã›ã‚“**ã€‚

`(a -> b)` ã‚’ã©ã†ãƒ‡ãƒ¼ã‚¿åŒ–ã™ã‚‹ã‹ï¼Ÿâ€”â€”**ä¸€èˆ¬çš„ãª** `(a -> b)` ã‚’ãƒ‡ãƒ¼ã‚¿åŒ–ã™ã‚‹ã“ã¨ã¯ä¸å¯èƒ½ã§ã™ã€‚Defunctionalization ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸­ã«ç¾ã‚Œã‚‹é–¢æ•°å€¤ã‚’æœ‰é™å€‹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§åˆ—æŒ™ã™ã‚‹æ‰‹æ³•ã§ã™ãŒã€`(a -> b)` ãŒè¡¨ã™è¨ˆç®—ã¯ç„¡é™ã«å¤šæ§˜ã§ã‚ã‚Šã€åˆ—æŒ™ã®å‰æãŒæˆã‚Šç«‹ã¡ã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ç§ãŸã¡ãŒä½œã‚ã†ã¨ã—ã¦ã„ã‚‹ DSL ã®å‘½ä»¤ã¯ã€ã‚‚ã£ã¨æ§‹é€ ãŒå˜ç´”ãªã¯ãšã§ã™ã€‚ã“ã®ã€Œæ§‹é€ ã€ã«ç€ç›®ã—ã€å‘½ä»¤ã‚»ãƒƒãƒˆï¼ˆFunctorï¼‰ã¨ã—ã¦æŠ½è±¡åŒ–ã™ã‚‹ã“ã¨ã§è‡ªç”±ãƒ¢ãƒŠãƒ‰ã‚’å°Žå‡ºã™ã‚‹ã®ãŒæ¬¡ç« ã®ãƒ†ãƒ¼ãƒžã§ã™ã€‚

> ðŸ“– å¯¾å¿œã‚³ãƒ¼ãƒ‰: [`haskell/src/Defunctionalization.hs`](../haskell/src/Defunctionalization.hs)
