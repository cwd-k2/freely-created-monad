# Freer ã®å®Ÿè¡ŒåŸºç›¤

## ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ

å‰ç« ã§ Freer ãƒ¢ãƒŠãƒ‰ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ Monad ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å°Žå‡ºã—ã¾ã—ãŸã€‚ã§ã¯ã€Freer ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿéš›ã«**å®Ÿè¡Œã™ã‚‹**ã«ã¯ã©ã†ã™ã‚Œã°ã‚ˆã„ã§ã—ã‚‡ã†ã‹ã€‚

ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒ Freer ã®å†…éƒ¨æ§‹é€ ï¼ˆ`Pure`/`Bind`ï¼‰ã‚’ç›´æŽ¥ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒã—ã¦ã‚‚ã‚ˆã„ã®ã§ã™ãŒã€ã“ã“ã§ã¯ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«**å¿…è¦ãªæƒ…å ±ã ã‘ã‚’å…¬é–‹**ã™ã‚‹ `Step` åž‹ã‚’å°Žå…¥ã—ã¾ã™ã€‚

```haskell
data Step f a where
  Done  :: a -> Step f a                        -- è¨ˆç®—å®Œäº†
  Await :: f x -> (x -> Freer f a) -> Step f a  -- å‘½ä»¤ + ç¶™ç¶š

viewFreer :: Freer f a -> Step f a
viewFreer (Pure a)    = Done a
viewFreer (Bind fx k) = Await fx k
```

ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ `Freer` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ä¾å­˜ã›ãšã€ã€Œè¨ˆç®—å®Œäº†ï¼ˆ`Done`ï¼‰ã‹ã€å‘½ä»¤å¾…ã¡ï¼ˆ`Await`ï¼‰ã‹ã€ã ã‘ã‚’è¦‹ã¾ã™ã€‚ç¾åœ¨ã®å®Ÿè£…ã§ã¯ `viewFreer` ã¯å˜ç´”ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®èª­ã¿æ›¿ãˆã§ã™ãŒã€å†…éƒ¨è¡¨ç¾ã‚’å¤‰æ›´ã—ã¦ã‚‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ã‚³ãƒ¼ãƒ‰ãŒå¤‰ã‚ã‚‰ãªã„ã¨ã„ã†åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ï¼ˆå¾Œè¿°ã® Codensity æœ€é©åŒ–ã‚’å†…éƒ¨åŒ–ã—ãŸå®Ÿè£…ã§ã¯ã“ã“ãŒéžè‡ªæ˜Žãªå‡¦ç†ã«ãªã‚Šã¾ã™ï¼‰ã€‚

```haskell
runStepIO :: Freer Talk a -> IO a
runStepIO m = case viewFreer m of
  Done a -> pure a
  Await (Ask prompt) k -> do
    putStrLn prompt
    input <- getLine
    runStepIO (k input)       -- ç¶™ç¶šã«å€¤ã‚’ä¾›çµ¦ã—ã¦å†é–‹
  Await (Tell msg) k -> do
    putStrLn msg
    runStepIO (k ())          -- ç¶™ç¶šã«å€¤ã‚’ä¾›çµ¦ã—ã¦å†é–‹
```

å„ã‚¹ãƒ†ãƒƒãƒ—ã§ï¼š

1. `viewFreer` ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å…ˆé ­ã‚’è¦—ã
2. å‘½ä»¤ã‚’å‡¦ç†ã™ã‚‹
3. ç¶™ç¶š `k` ã«çµæžœã‚’æ¸¡ã—ã¦å†é–‹ã™ã‚‹
4. å†å¸°çš„ã«æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸

ã“ã®ãƒ«ãƒ¼ãƒ—æ§‹é€ ã«ã¯åå‰ãŒã¤ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚æ¬¡ç¯€ã§è¦‹ã‚‹**é™å®šç¶™ç¶š**ã§ã™ã€‚

## é™å®šç¶™ç¶š

### ç¶™ç¶šã¨é™å®šç¶™ç¶šã®é•ã„

é€šå¸¸ã®ç¶™ç¶šï¼ˆcontinuationï¼‰ã¯**ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã®æ®‹ã‚Š**ã‚’è¡¨ã—ã¾ã™ã€‚

```
1 + (2 * â–¡)    -- â–¡ ã®ç¶™ç¶šã¯ã€Œ2ã‚’æŽ›ã‘ã¦1ã‚’è¶³ã™ã€= ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã®æ®‹ã‚Š
```

**é™å®šç¶™ç¶šï¼ˆdelimited continuationï¼‰** ã¯**ç‰¹å®šã®å¢ƒç•Œã¾ã§ã®æ®‹ã‚Š**ã‚’è¡¨ã—ã¾ã™ã€‚

```
reset (1 + (2 * shift k => ...))
       ^^^^^^^^^^^^^^^^^
       k ãŒæ•æ‰ã™ã‚‹ã®ã¯ã“ã“ã ã‘ï¼ˆreset ã¾ã§ã®ç¯„å›²ï¼‰
```

é™å®šç¶™ç¶šã®æž çµ„ã¿ã§ã¯ã€2ã¤ã®æ¼”ç®—å­ãŒåŸºæœ¬ã«ãªã‚Šã¾ã™ã€‚

- **`reset`**ï¼ˆãƒ‡ãƒªãƒŸã‚¿ï¼‰â€” ç¶™ç¶šã®æ•æ‰ç¯„å›²ã®å¢ƒç•Œã‚’è¨­å®šã™ã‚‹
- **`shift`**ï¼ˆæ•æ‰ï¼‰â€” ç¾åœ¨ã®ä½ç½®ã‹ã‚‰æœ€ã‚‚è¿‘ã„ `reset` ã¾ã§ã®ç¶™ç¶šã‚’æ•æ‰ã™ã‚‹

### Freer ã«ãŠã‘ã‚‹é™å®šç¶™ç¶š

å‰ç¯€ã®ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã¯ã€ã¾ã•ã«ã“ã® shift/reset ã®æ§‹é€ ã§ã™ã€‚

```haskell
data Freer f a where
  Pure :: a -> Freer f a
  Bind :: f x -> (x -> Freer f a) -> Freer f a
```

å¯¾å¿œé–¢ä¿‚ï¼š

| é™å®šç¶™ç¶š | Freer |
|---|---|
| `shift` | `send` â€” å‘½ä»¤ã‚’ç™ºè¡Œã—ã€æ®‹ã‚Šã®è¨ˆç®—ã‚’ç¶™ç¶šã¨ã—ã¦æ•æ‰ |
| `reset` | ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ«ãƒ¼ãƒ— â€” ç¶™ç¶šã®æ•æ‰ç¯„å›²ã‚’åŒºåˆ‡ã‚‹ |
| æ•æ‰ã•ã‚ŒãŸç¶™ç¶š `k` | `Bind` ã®ç¬¬2å¼•æ•° `(x -> Freer f a)` |
| ç¶™ç¶šã«å€¤ã‚’ä¾›çµ¦ | `k value` â€” ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒã§å–ã‚Šå‡ºã—ãŸ `k` ã«å€¤ã‚’æ¸¡ã™ |

`send` ã®å®šç¾©ã‚’æ€ã„å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```haskell
send :: f a -> Freer f a
send fa = Bind fa Pure
--        ^^^^ ^^  ^^^^
--        å‘½ä»¤  çµæžœ  ã€Œçµæžœã‚’ãã®ã¾ã¾è¿”ã™ã€ç¶™ç¶š
```

`send fa` ã¯ã€Œå‘½ä»¤ `fa` ã‚’ç™ºè¡Œã—ã€ãã®çµæžœã‚’ãã®ã¾ã¾è¿”ã™ã€ã¨ã„ã†æœ€å°ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã™ã€‚ã“ã‚ŒãŒ `do` è¨˜æ³•ã® `>>=` ã§ä»–ã®è¨ˆç®—ã¨çµåˆã•ã‚Œã‚‹ã¨ï¼š

```haskell
send (Ask "åå‰ã¯ï¼Ÿ") >>= \name -> send (Tell ("ã“ã‚“ã«ã¡ã¯ã€" ++ name))

-- >>= ã®å®šç¾©ã«ã‚ˆã‚Š:
= Bind (Ask "åå‰ã¯ï¼Ÿ") (\name -> send (Tell ("ã“ã‚“ã«ã¡ã¯ã€" ++ name)))
```

`Bind` ã®ç¬¬2å¼•æ•° `(\name -> ...)` ãŒé™å®šç¶™ç¶šã§ã™ã€‚ã€Œ`Ask` ã®çµæžœ `name` ã‚’å—ã‘å–ã£ã¦ã€æ®‹ã‚Šã®è¨ˆç®—ã‚’ç¶šã‘ã‚‹ã€ã¨ã„ã†ã€æ¬¡ã® `send`ï¼ˆ= `shift`ï¼‰ã¾ã§ã®ç¯„å›²ã‚’æ•æ‰ã—ã¦ã„ã¾ã™ã€‚

å‰ç¯€ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’æ”¹ã‚ã¦èª­ã‚€ã¨ã€`case viewFreer m of` ãŒ `reset`ï¼ˆå¢ƒç•Œã®è¨­å®šï¼‰ã€`Await` ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒãŒ `shift` ã§ä¸­æ–­ã•ã‚ŒãŸåœ°ç‚¹ã®å‡¦ç†ã€`k input` ãŒé™å®šç¶™ç¶šã¸ã®å€¤ã®ä¾›çµ¦ã§ã™ã€‚

ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒã€æ¬¡ç« ã§ TypeScript ã® Generator ã‚’ä½¿ã£ãŸ DSL å®Ÿè£…ã«ç›´æŽ¥å¯¾å¿œã—ã¾ã™ã€‚Generator ã® `yield` ãŒ `shift`ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã® `while` ãƒ«ãƒ¼ãƒ—ãŒ `reset` ã§ã™ã€‚

## Codensity ãƒ¢ãƒŠãƒ‰

ã“ã“ã¾ã§ã§ Freer ã®å®Ÿè¡Œæ–¹æ³•ã¯ç¢ºç«‹ã—ã¾ã—ãŸãŒã€å‰ç« ã§è§¦ã‚ŒãŸæ€§èƒ½ã®å•é¡ŒãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚Freer ãƒ¢ãƒŠãƒ‰ã® `>>=` ã¯ç¶™ç¶šã‚’é–¢æ•°åˆæˆã§é€£éŽ–ã•ã›ã¾ã™ã€‚

```haskell
Bind fx k >>= f = Bind fx ((>>= f) . k)
```

å·¦çµåˆã® `>>=` ãƒã‚§ãƒ¼ãƒ³ `(((m >>= f) >>= g) >>= h)` ã§ã¯ç¶™ç¶šãŒå…¥ã‚Œå­ã«ãªã‚Šã€å®Ÿè¡Œæ™‚ã« O(nÂ²) ã®ã‚³ã‚¹ãƒˆãŒã‹ã‹ã‚Šå¾—ã¾ã™ã€‚

**Codensity ãƒ¢ãƒŠãƒ‰** ã¯ã“ã®å•é¡Œã‚’è§£æ±ºã—ã¾ã™ã€‚

```haskell
newtype Codensity m a = Codensity
  { runCodensity :: forall r. (a -> m r) -> m r }
```

ã“ã‚Œã¯ã€ŒCPS å¤‰æ›ã•ã‚ŒãŸãƒ¢ãƒŠãƒ‰ã€ã§ã™ã€‚Monad ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ï¼š

```haskell
instance Monad (Codensity m) where
  Codensity m >>= f = Codensity (\k -> m (\a -> runCodensity (f a) k))
```

`>>=` ãŒå¸¸ã« **O(1)** ã«ãªã‚Šã¾ã™ã€‚ç¶™ç¶šã®çµåˆæ–¹å‘ãŒå³çµåˆã«çŸ¯æ­£ã•ã‚Œã‚‹ãŸã‚ã§ã™ã€‚

ãƒªã‚¹ãƒˆã® `(++)` ãŒå·¦çµåˆã§ O(nÂ²) ã«ãªã‚‹ã®ã‚’å·®åˆ†ãƒªã‚¹ãƒˆ `[a] -> [a]` ã§ O(n) ã«ã™ã‚‹ã®ã¨åŒã˜ç™ºæƒ³ã§ã™ã€‚

### ãªãœçµåˆã‚’è‡ªç”±ã«å¤‰ãˆã‚‰ã‚Œã‚‹ã®ã‹ â€” ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªã‚·ãƒ†ã‚£

Codensity ã®åž‹ã‚’ã‚‚ã†ä¸€åº¦è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```haskell
forall r. (a -> m r) -> m r
```

`forall r.` ã¯ã€Œ**ä»»æ„ã®** åž‹ `r` ã«å¯¾ã—ã¦å‹•ä½œã™ã‚‹ã€ã¨ã„ã†æ„å‘³ã§ã™ã€‚ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªã‚·ãƒ†ã‚£ï¼ˆparametricityï¼‰ã«ã‚ˆã‚Šã€ã“ã®åž‹ã®å€¤ `m` ã¯ `r` ã«ã¤ã„ã¦**ä½•ã‚‚çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“**ã€‚

å…·ä½“çš„ã«ã¯ã€`m` ã«ã§ãã‚‹ã“ã¨ã¯ï¼š

1. æ‰‹å…ƒã® `a` åž‹ã®å€¤ã‚’ç¶™ç¶š `k : a -> m r` ã«æ¸¡ã—ã¦ `m r` ã‚’å¾—ã‚‹
2. å¾—ã‚‰ã‚ŒãŸ `m r` ã‚’ãã®ã¾ã¾è¿”ã™

ã“ã‚Œ**ã ã‘**ã§ã™ã€‚`r` ãŒä½•ã§ã‚ã‚‹ã‹ã«ã‚ˆã£ã¦æŒ¯ã‚‹èˆžã„ã‚’å¤‰ãˆã‚‹ã“ã¨ã¯ä¸å¯èƒ½ã§ã™ã€‚`m r` ã®ä¸­èº«ã‚’èª¿ã¹ã‚‹ã“ã¨ã‚‚ã€`r` åž‹ã®å€¤ã‚’ç‹¬è‡ªã«æ§‹ç¯‰ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã›ã‚“ã€‚

å®Ÿéš›ã«ã€Codensity ã® `>>=` ãŒçµåˆå¾‹ã‚’æº€ãŸã™ã“ã¨ã¯ç›´æŽ¥è¨ˆç®—ã§ç¢ºèªã§ãã¾ã™ã€‚

```
(Codensity m >>= f) >>= g
= Codensity (\k -> m (\a -> runCodensity (f a) (\b -> runCodensity (g b) k)))

Codensity m >>= (\a -> f a >>= g)
= Codensity (\k -> m (\a -> runCodensity (f a >>= g) k))
= Codensity (\k -> m (\a -> runCodensity (f a) (\b -> runCodensity (g b) k)))
```

ä¸¡è¾ºãŒä¸€è‡´ã—ã¾ã™ã€‚ã“ã®è¨ˆç®—ãŒæˆã‚Šç«‹ã¤èƒŒæ™¯ã«ã¯**ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªã‚·ãƒ†ã‚£**ãŒã‚ã‚Šã¾ã™ã€‚`forall r.` ã«ã‚ˆã‚Š `Codensity m a` ã®å€¤ã¯ `r` ã«ã¤ã„ã¦ä½•ã‚‚çŸ¥ã‚‹ã“ã¨ãŒã§ããšã€ç¶™ç¶šã‚’ã€Œå‘¼ã¶ä»¥å¤–ã«ä½•ã‚‚ã§ããªã„ã€ãŸã‚ã€ç¶™ç¶šã®åˆæˆé †åºã‚’è‡ªç”±ã«çµ„ã¿æ›¿ãˆã¦ã‚‚è¦³æ¸¬å¯èƒ½ãªå·®ãŒç”Ÿã˜ã¾ã›ã‚“ã€‚

ã“ã‚Œã¯å·®åˆ†ãƒªã‚¹ãƒˆã®å ´åˆã¨åŒæ§˜ã§ã™ã€‚`\xs -> [1,2,3] ++ xs` ã¨ã„ã†é–¢æ•°ã«å¯¾ã—ã¦ã€`xs` ã®å…·ä½“çš„ãªä¸­èº«ã¯è¦‹ãˆã¾ã›ã‚“ã€‚ã ã‹ã‚‰ `(f . g) . h` ã¨ `f . (g . h)` ã‚’åŒºåˆ¥ã™ã‚‹æ–¹æ³•ãŒãªãã€é–¢æ•°åˆæˆã®çµåˆå¾‹ãŒãã®ã¾ã¾ãƒªã‚¹ãƒˆã® `(++)` ã®çµåˆå¾‹ã‚’ä¿è¨¼ã—ã¾ã™ã€‚

### Freer ã¨ã®æŽ¥ç¶š

Freer ã® `>>=` ãŒå·¦çµåˆã§ O(nÂ²) ã«ãªã‚‹å•é¡Œã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®**æ§‹ç¯‰æ™‚**ã« `Codensity (Freer f)` ã‚’ä½¿ã„ã€**å®Ÿè¡Œæ™‚**ã« `lowerCodensity` ã§æˆ»ã™ã“ã¨ã§è§£æ±ºã§ãã¾ã™ã€‚

```haskell
liftCodensity :: Monad m => m a -> Codensity m a
liftCodensity m = Codensity (m >>=)

lowerCodensity :: Monad m => Codensity m a -> m a
lowerCodensity (Codensity f) = f pure
```

do è¨˜æ³•ã¯ `>>=` ã‚’**å³çµåˆã«ãƒ‡ã‚·ãƒ¥ã‚¬ãƒ¼**ã™ã‚‹ãŸã‚ã€do è¨˜æ³•ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ„ã¿ç«‹ã¦ã‚‹é™ã‚Šã“ã®å•é¡Œã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã€‚å·¦çµåˆãƒã‚§ãƒ¼ãƒ³ãŒç¾ã‚Œã‚‹ã®ã¯ã€do è¨˜æ³•ã®å¤–ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ çš„ã« `>>=` ã‚’åå¾©é©ç”¨ã™ã‚‹å ´åˆï¼ˆä¾‹: `foldl (>>=) m fs`ï¼‰ã«é™ã‚‰ã‚Œã¾ã™ã€‚æœ¬è³‡æ–™ã® DSL å®Ÿè£…ã¯ do è¨˜æ³•ï¼ˆTypeScript ã§ã¯ Generatorï¼‰ã®ã¿ã‚’ä½¿ã†ãŸã‚ã€Codensity ã«ã‚ˆã‚‹æœ€é©åŒ–ã¯è¡Œã„ã¾ã›ã‚“ã€‚

ãªãŠã€Codensity ã«ã‚ˆã‚‹æœ€é©åŒ–ãŒæ©Ÿèƒ½ã™ã‚‹ã®ã¯ã€ç¶™ç¶šã‚’**é–¢æ•°ã¨ã—ã¦è‡ªç”±ã«åˆæˆãƒ»å†æ§‹æˆã§ãã‚‹**ã‹ã‚‰ã§ã™ã€‚Haskell ã® Freer ã§ã¯ç¶™ç¶š `(x -> Freer f a)` ã¯é€šå¸¸ã®é–¢æ•°ãªã®ã§ã“ã‚ŒãŒå¯èƒ½ã§ã™ãŒã€ç¶™ç¶šãŒ**ä¸€åº¦ã—ã‹ä½¿ãˆãªã„**ï¼ˆone-shotï¼‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ã¯ã€åˆæˆã®å†çµåˆè‡ªä½“ãŒæ„å‘³ã‚’æŒã¡ã¾ã›ã‚“ã€‚æ¬¡ç« ã§è¦‹ã‚‹ TypeScript ã® Generator ã¯ã¾ã•ã«ã“ã® one-shot ã®åˆ¶ç´„ã‚’æŒã£ã¦ãŠã‚Šã€Codensity ãŒä¸è¦ã§ã‚ã‚‹ã ã‘ã§ãªãã€ãã‚‚ãã‚‚é©ç”¨ã§ããªã„ã¨ã„ã†äº‹æƒ…ãŒã‚ã‚Šã¾ã™ã€‚

> ðŸ“– å¯¾å¿œã‚³ãƒ¼ãƒ‰: [`haskell/src/Codensity.hs`](../haskell/src/Codensity.hs)
