# Freer ã¨é™å®šç¶™ç¶š

å‰ç« ã§ã€Free ãƒ¢ãƒŠãƒ‰ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚ã‚‹ã“ã¨ã‚’èªè­˜ã—ã¾ã—ãŸã€‚ã—ã‹ã— Free ãƒ¢ãƒŠãƒ‰ã«ã¯ Functor åˆ¶ç´„ã¨ã„ã†è·ç‰©ãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚ã“ã®ç« ã§ã¯ Functor åˆ¶ç´„ã‚’å–ã‚Šé™¤ã„ã¦ Freer ãƒ¢ãƒŠãƒ‰ã‚’å°å‡ºã—ã€ã•ã‚‰ã«ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã‚’æ•´ç†ã™ã‚‹ã“ã¨ã§ã€ãã“ã«**é™å®šç¶™ç¶š**ï¼ˆshift/resetï¼‰ã®æ§‹é€ ãŒæ½œã‚“ã§ã„ã‚‹ã“ã¨ã‚’è¦‹å‡ºã—ã¾ã™ã€‚ã“ã‚ŒãŒ ch01 ã§ç¤ºã—ãŸè»¸3ã®åˆ°é”ç‚¹ã§ã‚ã‚Šã€æ¬¡ç« ã® Generator ã¸ã®ç›´æ¥çš„ãªæ©‹æ¸¡ã—ã«ãªã‚Šã¾ã™ã€‚

## Free ãƒ¢ãƒŠãƒ‰ã® bind ã‚’è¦³å¯Ÿã™ã‚‹

å‰ç« æœ«å°¾ã§æŒ‡æ‘˜ã—ãŸ Functor åˆ¶ç´„ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ã€Free ãƒ¢ãƒŠãƒ‰ã® `>>=` ãŒã©ã†å‹•ãã‹ã‚’è©³ã—ãè¿½ã£ã¦ã¿ã¾ã™ã€‚

```haskell
data Free f a = Pure a | Free (f (Free f a))

instance Functor f => Monad (Free f) where
  return = Pure
  Pure a >>= f = f a
  Free fx >>= f = Free (fmap (>>= f) fx)
```

`>>=` ã®å‹•ãã‚’å…·ä½“çš„ã«è¿½ã£ã¦ã¿ã¾ã™ã€‚

```
Free (Ask "åå‰" (\name -> Free (Tell name (Pure ()))))  >>= g

-- fmap ãŒå†å¸°çš„ã«æ½œã£ã¦ã„ã:
= Free (Ask "åå‰" (\name -> Free (Tell name (Pure () >>= g))))
= Free (Ask "åå‰" (\name -> Free (Tell name (g ()))))
```

`Free fx >>= f = Free (fmap (>>= f) fx)` ã‚’è¦‹ã‚‹ã¨ã€`>>=` ã¯ `fmap` ã‚’é€šã˜ã¦**å‘½ä»¤ `fx` ã®å†…éƒ¨ã«æ½œã‚Šè¾¼ã¿**ã€æœ«å°¾ã® `Pure` ã‚’æ›¸ãæ›ãˆã¦ã„ã¾ã™ã€‚ã“ã“ã«2ã¤ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚

1. **Functor åˆ¶ç´„**: `fmap` ã‚’ä½¿ã†ãŸã‚ã€å‘½ä»¤ã‚»ãƒƒãƒˆ `f` ãŒ Functor ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„
2. **æ€§èƒ½**: `>>=` ã®ãŸã³ã«æ§‹é€ å…¨ä½“ã‚’èµ°æŸ»ã™ã‚‹ãŸã‚ã€å·¦çµåˆãƒã‚§ãƒ¼ãƒ³ã§ O(nÂ²) ã«ãªã‚‹

ã©ã¡ã‚‰ã®å•é¡Œã‚‚ã€`fmap` ã§å‘½ä»¤ã®å†…éƒ¨ã«æ½œã‚‹æ§‹é€ ã«èµ·å› ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã—å‘½ä»¤ `fx` ã¨ç¶™ç¶šã‚’åˆ†é›¢ã—ã¦ä¿æŒã—ã€`>>=` ã§ã¯ç¶™ç¶šã‚’åˆæˆã™ã‚‹ã ã‘ã«ã§ãã‚Œã°ï¼š

```haskell
Bind fx k >>= f = Bind fx ((>>= f) . k)
-- å‘½ä»¤ã®å†…éƒ¨ã«æ½œã‚‰ãšã€ç¶™ç¶šã‚’é–¢æ•°åˆæˆã§å»¶é•·ã™ã‚‹ã ã‘
```

`fmap` ãŒä¸è¦ã«ãªã‚Šã€Functor åˆ¶ç´„ãŒæ¶ˆãˆã¾ã™ã€‚

> **æ€§èƒ½ã«ã¤ã„ã¦**: ã“ã®æ§‹é€ ã§ã¯å€‹ã€…ã® `>>=` ã¯ O(1) ã§ã™ãŒã€å·¦çµåˆãƒã‚§ãƒ¼ãƒ³å…¨ä½“ã® O(nÂ²) å•é¡Œã¯æ®‹ã‚Šã¾ã™ï¼ˆè“„ç©ã•ã‚ŒãŸç¶™ç¶šã®å®Ÿè¡Œæ™‚ã«å†ã³ç¾ã‚Œã‚‹ãŸã‚ï¼‰ã€‚ã“ã‚Œã¯è£œéºã§ **Codensity ãƒ¢ãƒŠãƒ‰** ã«ã‚ˆã£ã¦è§£æ±ºã—ã¾ã™ã€‚

ã—ã‹ã—ã€ã“ã®ç›´è¦³ã ã‘ã§ã¯ `Free (f (Free f a))` ãŒã©ã†ã—ã¦ `Bind :: f x -> (x -> Freer f a) -> Freer f a` ã¨ã„ã†å½¢ã«ãªã‚‹ã®ã‹â€”â€”ç‰¹ã«å­˜åœ¨é‡åŒ–ã•ã‚ŒãŸå‹å¤‰æ•° `x` ãŒã©ã“ã‹ã‚‰æ¥ã‚‹ã®ã‹â€”â€”ãŒæ˜ã‚‰ã‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã‚’å³å¯†ã«å°å‡ºã™ã‚‹ã®ãŒã€æ¬¡ç¯€ã® Coyoneda ã§ã™ã€‚

## Coyoneda

å‰ç¯€ã®ç›´è¦³ã‚’å³å¯†ã«å°ããŸã‚ã«ã€**Coyoneda** ã¨ã„ã†æ§‹æˆã‚’å°å…¥ã—ã¾ã™ã€‚

```haskell
data Coyoneda f a where
  Coyoneda :: (x -> a) -> f x -> Coyoneda f a
```

`Coyoneda f a` ã¯ã€Œ`f x` ã®å€¤ã¨ã€çµæœã‚’ `x` ã‹ã‚‰ `a` ã«å¤‰æ›ã™ã‚‹é–¢æ•°ã®ãƒšã‚¢ã€ã§ã™ã€‚`fmap` ã‚’å®Ÿéš›ã« `f` ã«é©ç”¨ã™ã‚‹ã®ã§ã¯ãªãã€å¤‰æ›é–¢æ•°ã‚’è“„ç©ã—ã¦ãŠãã¾ã™ã€‚

ã“ã®æ§‹æˆã®éµã¯ã€**`f` ãŒ Functor ã§ãªãã¦ã‚‚ `Coyoneda f` ã¯ Functor ã«ãªã‚‹**ã“ã¨ã§ã™ã€‚

```haskell
instance Functor (Coyoneda f) where
  fmap g (Coyoneda h fx) = Coyoneda (g . h) fx
  -- g ã®é©ç”¨ã‚’é–¢æ•°åˆæˆã§è“„ç©ã™ã‚‹ã ã‘ã€‚f ã® fmap ã¯ä¸€åˆ‡ä½¿ã‚ãªã„ã€‚
```

`Coyoneda` ã¯ä»»æ„ã®å‹æ§‹æˆå­ `f :: * -> *` ã‹ã‚‰ Functor ã‚’ç”Ÿã¿å‡ºã™æ™®éçš„ãªæ§‹æˆã§ã‚ã‚Šã€åœè«–ã«ãŠã‘ã‚‹**ç±³ç”°ã®è£œé¡Œï¼ˆYoneda Lemmaï¼‰** ã«ç”±æ¥ã™ã‚‹åå‰ã§ã™ã€‚`f` ãŒ Functor ã§ã‚ã‚‹å ´åˆã«ã¯ `Coyoneda f a â‰… f a` ãŒæˆã‚Šç«‹ã¡ã¾ã™ãŒã€Freer ã®å°å‡ºã§ä½¿ã†ã®ã¯åŒå‹æ€§ã§ã¯ãªãã€**`Coyoneda f` ãŒå¸¸ã« Functor ã«ãªã‚‹**ã¨ã„ã†æ§‹æˆçš„äº‹å®Ÿã®ã»ã†ã§ã™ã€‚

## Freer ãƒ¢ãƒŠãƒ‰ã®å°å‡º

ã“ã® Coyoneda ã‚’ä½¿ã£ã¦ã€Freer ãƒ¢ãƒŠãƒ‰ã‚’å³å¯†ã«å°å‡ºã—ã¾ã™ã€‚

å‡ºç™ºç‚¹ã¯ `Free (Coyoneda f) a` ã§ã™ã€‚`Coyoneda f` ã¯ `f` ãŒ Functor ã§ãªãã¦ã‚‚ Functor ã«ãªã‚‹ã®ã§ã€ã“ã®å‹ã¯ä»»æ„ã® `f` ã«å¯¾ã—ã¦ Free ãƒ¢ãƒŠãƒ‰ã¨ã—ã¦æˆç«‹ã—ã¾ã™ã€‚

`Free` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å±•é–‹ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```
Free (Coyoneda f (Free (Coyoneda f) a))
= Free (exists x. (x -> Free (Coyoneda f) a, f x))
```

å­˜åœ¨é‡åŒ–ã•ã‚ŒãŸ `x` ã«ã¤ã„ã¦ã€`f x`ï¼ˆå‘½ä»¤ï¼‰ã¨ `x -> Free (Coyoneda f) a`ï¼ˆç¶™ç¶šï¼‰ã®ãƒšã‚¢ã‚’æŒã¤â€”â€”ã“ã‚Œã¯ã¾ã•ã«å‰ç¯€ã§å‹•æ©Ÿã¨ã—ã¦æã„ãŸã€Œå‘½ä»¤ã¨ç¶™ç¶šã®åˆ†é›¢ã€ã®æ§‹é€ ã§ã™ã€‚

ã“ã®å±•é–‹çµæœã‚’ãã®ã¾ã¾ GADT ã¨ã—ã¦å®šç¾©ã™ã‚Œã°ã€Freer ãƒ¢ãƒŠãƒ‰ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚

```haskell
data Freer f a where
  Pure :: a -> Freer f a
  Bind :: f x -> (x -> Freer f a) -> Freer f a
```

å„æ§‹æˆå­ã®æ„å‘³ï¼š

- `Pure a` â€” è¨ˆç®—å®Œäº†ã€å€¤ `a` ã‚’æŒã¤ï¼ˆFree ã® `Pure` ã¨åŒã˜ï¼‰
- `Bind fx k` â€” å‘½ä»¤ `fx`ï¼ˆçµæœã®å‹ã¯ `x`ï¼‰ã‚’å®Ÿè¡Œã—ã€çµæœã‚’ç¶™ç¶š `k` ã«æ¸¡ã™ï¼ˆCoyoneda åˆ†è§£ã§å¾—ã‚‰ã‚ŒãŸæ§‹é€ ï¼‰

**`f` ã« Functor åˆ¶ç´„ãŒãªã„** ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚Coyoneda ãŒ `fmap` ã®å½¹å‰²ã‚’å¸åã—ãŸãŸã‚ã€`f` ã¯ä»»æ„ã® `* -> *` å‹ã§æ§‹ã„ã¾ã›ã‚“ã€‚å‘½ä»¤ `f x` ã¯ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿æŒã•ã‚Œã€ç¶™ç¶š `k` ã¯é–¢æ•°ã®ã¾ã¾æ®‹ã‚Šã¾ã™â€”â€”å‘½ä»¤ã‚»ãƒƒãƒˆã® Defunctionalizationï¼ˆch02ï¼‰ã¨ã€Functor å±¤ã® Coyoneda åˆ†è§£ãŒçµ„ã¿åˆã‚ã•ã£ãŸçµæœã§ã™ã€‚

## Monad ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

```haskell
instance Monad (Freer f) where
  Pure a    >>= f = f a
  Bind fx k >>= f = Bind fx ((>>= f) . k)
```

`Bind fx k >>= f` ã¯ã€ç¶™ç¶š `k` ã®å¾Œã‚ã« `f` ã‚’åˆæˆã™ã‚‹ã ã‘ã§ã™ã€‚`fmap` ã¯ä¸€åˆ‡ä½¿ã„ã¾ã›ã‚“ã€‚

## å‘½ä»¤ã‚»ãƒƒãƒˆã®ç°¡ç´ åŒ–

Functor åˆ¶ç´„ãŒä¸è¦ã«ãªã£ãŸã“ã¨ã§ã€å‘½ä»¤ã‚»ãƒƒãƒˆãŒæ ¼æ®µã«ã‚·ãƒ³ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚

```haskell
-- Freer ç‰ˆ: GADT ã§çµæœã®å‹ã‚’ç›´æ¥æŒ‡å®š
data Talk a where
  Ask  :: String -> Talk String   -- è³ªå•ã—ã¦æ–‡å­—åˆ—ã‚’å¾—ã‚‹
  Tell :: String -> Talk ()       -- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹
```

`(String -> next)` ã®ã‚ˆã†ãªç¶™ç¶šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å®Œå…¨ã«æ¶ˆãˆã¾ã—ãŸã€‚å‘½ä»¤ã®**æœ¬è³ªã ã‘**ãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚

```haskell
-- ä½¿ã„æ–¹ã¯ Free ç‰ˆã¨åŒã˜
talkProgram :: Freer Talk String
talkProgram = do
  name <- send (Ask "åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„")
  send (Tell ("ã“ã‚“ã«ã¡ã¯ã€" ++ name ++ "ã•ã‚“ï¼"))
  age <- send (Ask "å¹´é½¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„")
  send (Tell (age ++ "æ­³ã§ã™ã­ã€‚"))
  pure name
```

`send` ã¯å‘½ä»¤ã‚’ Freer ã«æŒã¡ä¸Šã’ã‚‹ã ã‘ã®é–¢æ•°ã§ã™ã€‚

```haskell
send :: f a -> Freer f a
send fa = Bind fa Pure
```

---

ã“ã“ã¾ã§ã§ Freer ãƒ¢ãƒŠãƒ‰ã®å®šç¾©ã‚’å¾—ã¾ã—ãŸã€‚å‘½ä»¤ã¨ç¶™ç¶šãŒå‹ãƒ¬ãƒ™ãƒ«ã§åˆ†é›¢ã•ã‚Œã€Functor åˆ¶ç´„ãŒæ¶ˆãˆã¾ã—ãŸã€‚ã“ã“ã‹ã‚‰ã¯ã€ã“ã®åˆ†é›¢ãŒã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®æ§‹é€ â€”â€”ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã¨é™å®šç¶™ç¶šâ€”â€”ã«ã©ã†åæ˜ ã•ã‚Œã‚‹ã‹ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

---

## ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã®æ•´ç†

å‰ç« ã§ Free ãƒ¢ãƒŠãƒ‰ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚ã‚‹ã“ã¨ã‚’èªè­˜ã—ã¾ã—ãŸã€‚Freer ã§ã¯å‘½ä»¤ã¨ç¶™ç¶šãŒåˆ†é›¢ã•ã‚ŒãŸã“ã¨ã§ã€ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚ˆã‚Šæ˜ç¢ºã«è¡¨ç¾ã§ãã¾ã™ã€‚

ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«**å¿…è¦ãªæƒ…å ±ã ã‘ã‚’å…¬é–‹**ã™ã‚‹ `Step` å‹ã‚’å°å…¥ã—ã¾ã™ã€‚

```haskell
data Step f a where
  Done  :: a -> Step f a                        -- è¨ˆç®—å®Œäº†
  Await :: f x -> (x -> Freer f a) -> Step f a  -- å‘½ä»¤ + ç¶™ç¶š

viewFreer :: Freer f a -> Step f a
viewFreer (Pure a)    = Done a
viewFreer (Bind fx k) = Await fx k
```

ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ `Freer` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ä¾å­˜ã›ãšã€ã€Œè¨ˆç®—å®Œäº†ï¼ˆ`Done`ï¼‰ã‹ã€å‘½ä»¤å¾…ã¡ï¼ˆ`Await`ï¼‰ã‹ã€ã ã‘ã‚’è¦‹ã¾ã™ã€‚ç¾åœ¨ã®å®Ÿè£…ã§ã¯ `viewFreer` ã¯å˜ç´”ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®èª­ã¿æ›¿ãˆã§ã™ãŒã€å†…éƒ¨è¡¨ç¾ã‚’å¤‰æ›´ã—ã¦ã‚‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ã‚³ãƒ¼ãƒ‰ãŒå¤‰ã‚ã‚‰ãªã„ã¨ã„ã†åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ï¼ˆCodensity æœ€é©åŒ–ã‚’å†…éƒ¨åŒ–ã—ãŸå®Ÿè£…ã§ã¯ã“ã“ãŒéè‡ªæ˜ãªå‡¦ç†ã«ãªã‚Šã¾ã™ï¼‰ã€‚

```haskell
runStepIO :: Freer Talk a -> IO a
runStepIO m = case viewFreer m of
  Done a -> pure a
  Await (Ask prompt) k -> do
    putStrLn prompt
    input <- getLine
    runStepIO (k input)       -- ç¶™ç¶šã«å€¤ã‚’ä¾›çµ¦ã—ã¦å†é–‹
  Await (Tell msg) k -> do
    putStrLn msg
    runStepIO (k ())          -- ç¶™ç¶šã«å€¤ã‚’ä¾›çµ¦ã—ã¦å†é–‹
```

å‰ç« ã® Free ç‰ˆã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¨æ¯”è¼ƒã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```
Free ç‰ˆ:   runTalkIO (Free (Ask prompt next)) = ... runTalkIO (next input)
Freer ç‰ˆ:  Await (Ask prompt) k              -> ... runStepIO (k input)
```

æ§‹é€ ã¯åŒã˜â€”â€”**å…ˆé ­ã‚’è¦—ãã€å‘½ä»¤ã‚’å‡¦ç†ã—ã€ç¶™ç¶šã«å€¤ã‚’æ¸¡ã™**â€”â€”ã§ã™ãŒã€Freer ç‰ˆã§ã¯å‘½ä»¤ `Ask prompt` ã¨ç¶™ç¶š `k` ãŒå‹ãƒ¬ãƒ™ãƒ«ã§åˆ†é›¢ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®åˆ†é›¢ãŒã€æ¬¡ç¯€ã®é™å®šç¶™ç¶šã¨ã„ã†è¦‹æ–¹ã‚’è‡ªç„¶ã«ã—ã¾ã™ã€‚

## é™å®šç¶™ç¶š

### ç¶™ç¶šã¨é™å®šç¶™ç¶šã®é•ã„

é€šå¸¸ã®ç¶™ç¶šï¼ˆcontinuationï¼‰ã¯**ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã®æ®‹ã‚Š**ã‚’è¡¨ã—ã¾ã™ã€‚

```
1 + (2 * â–¡)    -- â–¡ ã®ç¶™ç¶šã¯ã€Œ2ã‚’æ›ã‘ã¦1ã‚’è¶³ã™ã€= ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã®æ®‹ã‚Š
```

**é™å®šç¶™ç¶šï¼ˆdelimited continuationï¼‰** ã¯**ç‰¹å®šã®å¢ƒç•Œã¾ã§ã®æ®‹ã‚Š**ã‚’è¡¨ã—ã¾ã™ã€‚

```
reset (1 + (2 * shift k => ...))
       ^^^^^^^^^^^^^^^^^
       k ãŒæ•æ‰ã™ã‚‹ã®ã¯ã“ã“ã ã‘ï¼ˆreset ã¾ã§ã®ç¯„å›²ï¼‰
```

é™å®šç¶™ç¶šã®æ çµ„ã¿ã§ã¯ã€2ã¤ã®æ¼”ç®—å­ãŒåŸºæœ¬ã«ãªã‚Šã¾ã™ã€‚

- **`reset`**ï¼ˆãƒ‡ãƒªãƒŸã‚¿ï¼‰â€” ç¶™ç¶šã®æ•æ‰ç¯„å›²ã®å¢ƒç•Œã‚’è¨­å®šã™ã‚‹
- **`shift`**ï¼ˆæ•æ‰ï¼‰â€” ç¾åœ¨ã®ä½ç½®ã‹ã‚‰æœ€ã‚‚è¿‘ã„ `reset` ã¾ã§ã®ç¶™ç¶šã‚’æ•æ‰ã™ã‚‹

### Freer ã«ãŠã‘ã‚‹é™å®šç¶™ç¶š

å‰ç¯€ã®ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã¯ã€ã¾ã•ã«ã“ã® shift/reset ã®æ§‹é€ ã§ã™ã€‚

```haskell
data Freer f a where
  Pure :: a -> Freer f a
  Bind :: f x -> (x -> Freer f a) -> Freer f a
```

å¯¾å¿œé–¢ä¿‚ï¼š

| é™å®šç¶™ç¶š | Freer |
|---|---|
| `shift` | `send` â€” å‘½ä»¤ã‚’ç™ºè¡Œã—ã€æ®‹ã‚Šã®è¨ˆç®—ã‚’ç¶™ç¶šã¨ã—ã¦æ•æ‰ |
| `reset` | ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãƒ«ãƒ¼ãƒ— â€” ç¶™ç¶šã®æ•æ‰ç¯„å›²ã‚’åŒºåˆ‡ã‚‹ |
| æ•æ‰ã•ã‚ŒãŸç¶™ç¶š `k` | `Bind` ã®ç¬¬2å¼•æ•° `(x -> Freer f a)` |
| ç¶™ç¶šã«å€¤ã‚’ä¾›çµ¦ | `k value` â€” ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§å–ã‚Šå‡ºã—ãŸ `k` ã«å€¤ã‚’æ¸¡ã™ |

`send` ã®å®šç¾©ã‚’æ€ã„å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```haskell
send :: f a -> Freer f a
send fa = Bind fa Pure
--        ^^^^ ^^  ^^^^
--        å‘½ä»¤  çµæœ  ã€Œçµæœã‚’ãã®ã¾ã¾è¿”ã™ã€ç¶™ç¶š
```

`send fa` ã¯ã€Œå‘½ä»¤ `fa` ã‚’ç™ºè¡Œã—ã€ãã®çµæœã‚’ãã®ã¾ã¾è¿”ã™ã€ã¨ã„ã†æœ€å°ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã™ã€‚ã“ã‚ŒãŒ `do` è¨˜æ³•ã® `>>=` ã§ä»–ã®è¨ˆç®—ã¨çµåˆã•ã‚Œã‚‹ã¨ï¼š

```haskell
send (Ask "åå‰ã¯ï¼Ÿ") >>= \name -> send (Tell ("ã“ã‚“ã«ã¡ã¯ã€" ++ name))

-- >>= ã®å®šç¾©ã«ã‚ˆã‚Š:
= Bind (Ask "åå‰ã¯ï¼Ÿ") (\name -> send (Tell ("ã“ã‚“ã«ã¡ã¯ã€" ++ name)))
```

`Bind` ã®ç¬¬2å¼•æ•° `(\name -> ...)` ãŒé™å®šç¶™ç¶šã§ã™ã€‚ã€Œ`Ask` ã®çµæœ `name` ã‚’å—ã‘å–ã£ã¦ã€æ®‹ã‚Šã®è¨ˆç®—ã‚’ç¶šã‘ã‚‹ã€ã¨ã„ã†ã€æ¬¡ã® `send`ï¼ˆ= `shift`ï¼‰ã¾ã§ã®ç¯„å›²ã‚’æ•æ‰ã—ã¦ã„ã¾ã™ã€‚

å‰ç¯€ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’æ”¹ã‚ã¦èª­ã‚€ã¨ã€`case viewFreer m of` ãŒ `reset`ï¼ˆå¢ƒç•Œã®è¨­å®šï¼‰ã€`Await` ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãŒ `shift` ã§ä¸­æ–­ã•ã‚ŒãŸåœ°ç‚¹ã®å‡¦ç†ã€`k input` ãŒé™å®šç¶™ç¶šã¸ã®å€¤ã®ä¾›çµ¦ã§ã™ã€‚

## Generator ã¸ã®æ©‹æ¸¡ã—

æ¬¡ç« ã§ã¯ã€é™å®šç¶™ç¶šã‚’**è¨€èªãƒ¬ãƒ™ãƒ«ã§ç›´æ¥ã‚µãƒãƒ¼ãƒˆ**ã™ã‚‹ä»•çµ„ã¿â€”â€”Generator ã® `yield`/`next`â€”â€”ã‚’ä½¿ã£ã¦ã€TypeScript ã§ DSL ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

Generator ã® `yield` ã¯ shift ã«å¯¾å¿œã—ã¾ã™ã€‚ä¸¡è€…ã®å‹•ä½œã‚’ä¸¦ã¹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

- **shiftï¼ˆ= `send`ï¼‰**: å‘½ä»¤ã‚’ç™ºè¡Œã—ã€è‡ªåˆ†è‡ªèº«ã®æ®‹ã‚Šã®è¨ˆç®—ã‚’ç¶™ç¶šã¨ã—ã¦æ•æ‰ã™ã‚‹ã€‚åˆ¶å¾¡ã¯æœ€ã‚‚è¿‘ã„ `reset`ï¼ˆã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ï¼‰ã«ç§»ã‚‹
- **`yield`**: å€¤ï¼ˆå‘½ä»¤ï¼‰ã‚’å¤–ã«æ¸¡ã—ã¦ä¸­æ–­ã™ã‚‹ã€‚åˆ¶å¾¡ã¯å‘¼ã³å‡ºã—å…ƒï¼ˆã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã® `while` ãƒ«ãƒ¼ãƒ—ï¼‰ã«ç§»ã‚‹ã€‚å†é–‹æ™‚ã« `gen.next(value)` ã§å€¤ã‚’å—ã‘å–ã‚‹

ã©ã¡ã‚‰ã‚‚ã€Œå€¤ã‚’å¤–ã«æ¸¡ã—ã¦ä¸­æ–­ã—ã€å¤–å´ã‹ã‚‰å€¤ã‚’ä¾›çµ¦ã•ã‚Œã¦å†é–‹ã™ã‚‹ã€â€”â€”åŒã˜ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã® `while` ãƒ«ãƒ¼ãƒ—ãŒ `reset`ï¼ˆç¶™ç¶šã®æ•æ‰ç¯„å›²ã®å¢ƒç•Œï¼‰ã«å¯¾å¿œã—ã¾ã™ã€‚

> ğŸ“– å¯¾å¿œã‚³ãƒ¼ãƒ‰: [`haskell/src/Freer.hs`](../haskell/src/Freer.hs)
