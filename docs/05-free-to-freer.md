# Free ã‹ã‚‰ Freer ã¸

## Free ãƒ¢ãƒŠãƒ‰ã® Functor åˆ¶ç´„ã®å•é¡Œ

Free ãƒ¢ãƒŠãƒ‰ã®å‘½ä»¤ã‚»ãƒƒãƒˆã«ã¯ Functor ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå¿…è¦ã§ã—ãŸã€‚

```haskell
data TalkF next
  = Ask String (String -> next)   -- (String -> next) ã¯ fmap ã®ãŸã‚ã ã‘ã«å­˜åœ¨
  | Tell String next
  deriving Functor
```

`Ask` ã®ç¬¬2å¼•æ•° `(String -> next)` ã¯ã€Functor ã® `fmap` ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã‚ã‚Šã€å‘½ä»¤ã®æœ¬è³ªçš„ãªæƒ…å ±ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã€Œè³ªå•ã—ã¦æ–‡å­—åˆ—ã‚’å¾—ã‚‹ã€ã¨ã„ã†æƒ…å ±ã¯ `Ask String` ã ã‘ã§ååˆ†ã§ã™ã€‚

## Free ãƒ¢ãƒŠãƒ‰ã® bind ã‚’è¦³å¯Ÿã™ã‚‹

Free ãƒ¢ãƒŠãƒ‰ã®æ§‹é€ ã‚’ã‚‚ã†ä¸€åº¦è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```haskell
data Free f a = Pure a | Free (f (Free f a))

instance Functor f => Monad (Free f) where
  return = Pure
  Pure a >>= f = f a
  Free fx >>= f = Free (fmap (>>= f) fx)
```

`>>=` ã®å‹•ãã‚’å…·ä½“çš„ã«è¿½ã£ã¦ã¿ã¾ã™ã€‚

```
Free (Ask "åå‰" (\name -> Free (Tell name (Pure ()))))  >>= g

-- fmap ãŒå†å¸°çš„ã«æ½œã£ã¦ã„ã:
= Free (Ask "åå‰" (\name -> Free (Tell name (Pure () >>= g))))
= Free (Ask "åå‰" (\name -> Free (Tell name (g ()))))
```

`Free fx >>= f = Free (fmap (>>= f) fx)` ã‚’è¦‹ã‚‹ã¨ã€`>>=` ã¯ `fmap` ã‚’é€šã˜ã¦**å‘½ä»¤ `fx` ã®å†…éƒ¨ã«æ½œã‚Šè¾¼ã¿**ã€æœ«å°¾ã® `Pure` ã‚’æ›¸ãæ›ãˆã¦ã„ã¾ã™ã€‚ã“ã“ã«2ã¤ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚

1. **Functor åˆ¶ç´„**: `fmap` ã‚’ä½¿ã†ãŸã‚ã€å‘½ä»¤ã‚»ãƒƒãƒˆ `f` ãŒ Functor ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„
2. **æ€§èƒ½**: `>>=` ã®ãŸã³ã«æ§‹é€ å…¨ä½“ã‚’èµ°æŸ»ã™ã‚‹ãŸã‚ã€å·¦çµåˆãƒã‚§ãƒ¼ãƒ³ã§ O(nÂ²) ã«ãªã‚‹

ã©ã¡ã‚‰ã®å•é¡Œã‚‚ã€`fmap` ã§å‘½ä»¤ã®å†…éƒ¨ã«æ½œã‚‹æ§‹é€ ã«èµ·å› ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã—å‘½ä»¤ `fx` ã¨ç¶™ç¶šã‚’åˆ†é›¢ã—ã¦ä¿æŒã—ã€`>>=` ã§ã¯ç¶™ç¶šã‚’åˆæˆã™ã‚‹ã ã‘ã«ã§ãã‚Œã°ï¼š

```haskell
Bind fx k >>= f = Bind fx ((>>= f) . k)
-- å‘½ä»¤ã®å†…éƒ¨ã«æ½œã‚‰ãšã€ç¶™ç¶šã‚’é–¢æ•°åˆæˆã§å»¶é•·ã™ã‚‹ã ã‘
```

`fmap` ãŒä¸è¦ã«ãªã‚Šã€Functor åˆ¶ç´„ãŒæ¶ˆãˆã¾ã™ã€‚

> **æ€§èƒ½ã«ã¤ã„ã¦**: ã“ã®æ§‹é€ ã§ã¯å€‹ã€…ã® `>>=` ã¯ O(1) ã§ã™ãŒã€å·¦çµåˆãƒã‚§ãƒ¼ãƒ³å…¨ä½“ã® O(nÂ²) å•é¡Œã¯æ®‹ã‚Šã¾ã™ï¼ˆè“„ç©ã•ã‚ŒãŸç¶™ç¶šã®å®Ÿè¡Œæ™‚ã«å†ã³ç¾ã‚Œã‚‹ãŸã‚ï¼‰ã€‚ã“ã‚Œã¯å¾Œã®ç« ã§ **Codensity ãƒ¢ãƒŠãƒ‰** ã«ã‚ˆã£ã¦è§£æ±ºã—ã¾ã™ã€‚

ã—ã‹ã—ã€ã“ã®ç›´è¦³ã ã‘ã§ã¯ `Free (f (Free f a))` ãŒã©ã†ã—ã¦ `Bind :: f x -> (x -> Freer f a) -> Freer f a` ã¨ã„ã†å½¢ã«ãªã‚‹ã®ã‹â€”â€”ç‰¹ã«å­˜åœ¨é‡åŒ–ã•ã‚ŒãŸå‹å¤‰æ•° `x` ãŒã©ã“ã‹ã‚‰æ¥ã‚‹ã®ã‹â€”â€”ãŒæ˜ã‚‰ã‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã‚’å³å¯†ã«å°å‡ºã™ã‚‹ã®ãŒã€æ¬¡ç¯€ã® Coyoneda ã§ã™ã€‚

## Coyoneda

å‰ç¯€ã®ç›´è¦³ã‚’å³å¯†ã«å°ããŸã‚ã«ã€**Coyoneda** ã¨ã„ã†æ§‹æˆã‚’å°å…¥ã—ã¾ã™ã€‚

```haskell
data Coyoneda f a where
  Coyoneda :: (x -> a) -> f x -> Coyoneda f a
```

`Coyoneda f a` ã¯ã€Œ`f x` ã®å€¤ã¨ã€çµæœã‚’ `x` ã‹ã‚‰ `a` ã«å¤‰æ›ã™ã‚‹é–¢æ•°ã®ãƒšã‚¢ã€ã§ã™ã€‚`fmap` ã‚’å®Ÿéš›ã« `f` ã«é©ç”¨ã™ã‚‹ã®ã§ã¯ãªãã€å¤‰æ›é–¢æ•°ã‚’è“„ç©ã—ã¦ãŠãã¾ã™ã€‚

ã“ã®æ§‹æˆã®éµã¯ã€**`f` ãŒ Functor ã§ãªãã¦ã‚‚ `Coyoneda f` ã¯ Functor ã«ãªã‚‹**ã“ã¨ã§ã™ã€‚

```haskell
instance Functor (Coyoneda f) where
  fmap g (Coyoneda h fx) = Coyoneda (g . h) fx
  -- g ã®é©ç”¨ã‚’é–¢æ•°åˆæˆã§è“„ç©ã™ã‚‹ã ã‘ã€‚f ã® fmap ã¯ä¸€åˆ‡ä½¿ã‚ãªã„ã€‚
```

`Coyoneda` ã¯ä»»æ„ã®å‹æ§‹æˆå­ `f :: * -> *` ã‹ã‚‰ Functor ã‚’ç”Ÿã¿å‡ºã™æ™®éçš„ãªæ§‹æˆã§ã‚ã‚Šã€åœè«–ã«ãŠã‘ã‚‹**ç±³ç”°ã®è£œé¡Œï¼ˆYoneda Lemmaï¼‰** ã«ç”±æ¥ã™ã‚‹åå‰ã§ã™ã€‚`f` ãŒ Functor ã§ã‚ã‚‹å ´åˆã«ã¯ `Coyoneda f a â‰… f a` ãŒæˆã‚Šç«‹ã¡ã¾ã™ãŒã€Freer ã®å°å‡ºã§ä½¿ã†ã®ã¯åŒå‹æ€§ã§ã¯ãªãã€**`Coyoneda f` ãŒå¸¸ã« Functor ã«ãªã‚‹**ã¨ã„ã†æ§‹æˆçš„äº‹å®Ÿã®ã»ã†ã§ã™ã€‚

## Freer ãƒ¢ãƒŠãƒ‰ã®å°å‡º

ã“ã® Coyoneda ã‚’ä½¿ã£ã¦ã€Freer ãƒ¢ãƒŠãƒ‰ã‚’å³å¯†ã«å°å‡ºã—ã¾ã™ã€‚

å‡ºç™ºç‚¹ã¯ `Free (Coyoneda f) a` ã§ã™ã€‚`Coyoneda f` ã¯ `f` ãŒ Functor ã§ãªãã¦ã‚‚ Functor ã«ãªã‚‹ã®ã§ã€ã“ã®å‹ã¯ä»»æ„ã® `f` ã«å¯¾ã—ã¦ Free ãƒ¢ãƒŠãƒ‰ã¨ã—ã¦æˆç«‹ã—ã¾ã™ã€‚

`Free` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å±•é–‹ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```
Free (Coyoneda f (Free (Coyoneda f) a))
= Free (exists x. (x -> Free (Coyoneda f) a, f x))
```

å­˜åœ¨é‡åŒ–ã•ã‚ŒãŸ `x` ã«ã¤ã„ã¦ã€`f x`ï¼ˆå‘½ä»¤ï¼‰ã¨ `x -> Free (Coyoneda f) a`ï¼ˆç¶™ç¶šï¼‰ã®ãƒšã‚¢ã‚’æŒã¤â€”â€”ã“ã‚Œã¯ã¾ã•ã«å‰ç¯€ã§å‹•æ©Ÿã¨ã—ã¦æã„ãŸã€Œå‘½ä»¤ã¨ç¶™ç¶šã®åˆ†é›¢ã€ã®æ§‹é€ ã§ã™ã€‚

ã“ã®å±•é–‹çµæœã‚’ãã®ã¾ã¾ GADT ã¨ã—ã¦å®šç¾©ã™ã‚Œã°ã€Freer ãƒ¢ãƒŠãƒ‰ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚

```haskell
data Freer f a where
  Pure :: a -> Freer f a
  Bind :: f x -> (x -> Freer f a) -> Freer f a
```

å„æ§‹æˆå­ã®æ„å‘³ï¼š

- `Pure a` â€” è¨ˆç®—å®Œäº†ã€å€¤ `a` ã‚’æŒã¤ï¼ˆFree ã® `Pure` ã¨åŒã˜ï¼‰
- `Bind fx k` â€” å‘½ä»¤ `fx`ï¼ˆçµæœã®å‹ã¯ `x`ï¼‰ã‚’å®Ÿè¡Œã—ã€çµæœã‚’ç¶™ç¶š `k` ã«æ¸¡ã™ï¼ˆCoyoneda åˆ†è§£ã§å¾—ã‚‰ã‚ŒãŸæ§‹é€ ï¼‰

**`f` ã« Functor åˆ¶ç´„ãŒãªã„** ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚Coyoneda ãŒ `fmap` ã®å½¹å‰²ã‚’å¸åã—ãŸãŸã‚ã€`f` ã¯ä»»æ„ã® `* -> *` å‹ã§æ§‹ã„ã¾ã›ã‚“ã€‚å‘½ä»¤ `f x` ã¯ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿æŒã•ã‚Œã€ç¶™ç¶š `k` ã¯é–¢æ•°ã®ã¾ã¾æ®‹ã‚Šã¾ã™â€”â€”å‘½ä»¤ã‚»ãƒƒãƒˆã® Defunctionalizationï¼ˆch03ï¼‰ã¨ã€Functor å±¤ã® Coyoneda åˆ†è§£ãŒçµ„ã¿åˆã‚ã•ã£ãŸçµæœã§ã™ã€‚

## Monad ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

```haskell
instance Monad (Freer f) where
  Pure a    >>= f = f a
  Bind fx k >>= f = Bind fx ((>>= f) . k)
```

`Bind fx k >>= f` ã¯ã€ç¶™ç¶š `k` ã®å¾Œã‚ã« `f` ã‚’åˆæˆã™ã‚‹ã ã‘ã§ã™ã€‚`fmap` ã¯ä¸€åˆ‡ä½¿ã„ã¾ã›ã‚“ã€‚

## å‘½ä»¤ã‚»ãƒƒãƒˆã®ç°¡ç´ åŒ–

Functor åˆ¶ç´„ãŒä¸è¦ã«ãªã£ãŸã“ã¨ã§ã€å‘½ä»¤ã‚»ãƒƒãƒˆãŒæ ¼æ®µã«ã‚·ãƒ³ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚

```haskell
-- Freer ç‰ˆ: GADT ã§çµæœã®å‹ã‚’ç›´æ¥æŒ‡å®š
data Talk a where
  Ask  :: String -> Talk String   -- è³ªå•ã—ã¦æ–‡å­—åˆ—ã‚’å¾—ã‚‹
  Tell :: String -> Talk ()       -- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹
```

`(String -> next)` ã®ã‚ˆã†ãªç¶™ç¶šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å®Œå…¨ã«æ¶ˆãˆã¾ã—ãŸã€‚å‘½ä»¤ã®**æœ¬è³ªã ã‘**ãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚

```haskell
-- ä½¿ã„æ–¹ã¯ Free ç‰ˆã¨åŒã˜
talkProgram :: Freer Talk String
talkProgram = do
  name <- send (Ask "åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„")
  send (Tell ("ã“ã‚“ã«ã¡ã¯ã€" ++ name ++ "ã•ã‚“ï¼"))
  age <- send (Ask "å¹´é½¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„")
  send (Tell (age ++ "æ­³ã§ã™ã­ã€‚"))
  pure name
```

`send` ã¯å‘½ä»¤ã‚’ Freer ã«æŒã¡ä¸Šã’ã‚‹ã ã‘ã®é–¢æ•°ã§ã™ã€‚

```haskell
send :: f a -> Freer f a
send fa = Bind fa Pure
```

> ğŸ“– å¯¾å¿œã‚³ãƒ¼ãƒ‰: [`haskell/src/Freer.hs`](../haskell/src/Freer.hs)
