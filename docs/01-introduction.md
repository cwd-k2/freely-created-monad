# Generator で DSL — 自由に手に入るモナド

## 問題: プログラムの定義と実行が密結合している

ビジネスロジックを書くとき、私たちは「何をするか」と「どう実行するか」を同時に書いてしまいがちです。コンソールに出力するコードを書けば、そのロジックはコンソールでしか動きません。テストしたければモックが必要になり、Web API に転用するには書き直しが必要です。

この勉強会では、**プログラムの定義と実行を分離する**ための仕組みを、基礎から段階的に構築していきます。

## ゴール

最終的に、TypeScript で **DSL（ドメイン特化言語）** を書けるようになることを目指します。

```typescript
// 最終形のイメージ
const program: Program<string> = function* () {
  const name = yield* ask("名前を入力してください");
  yield* tell(`こんにちは、${name}さん！`);
  const age = yield* ask("年齢を入力してください");
  yield* tell(`${age}歳ですね。`);
  return name;
};
```

この `program` はまだ**実行されていません**。プログラムの「構造」がデータとして記述されているだけです。実行方法は後から自由に差し替えられます——コンソール対話、テスト用のモック、ログ収集など。一度書いたビジネスロジックを、CLI ツール、Web API、対話的な GUI アプリとして、**ロジックのコードを一行も変えずに**再利用できるのです。

この柔軟性を支えている仕組みが **Freer モナド** であり、そこに至る道筋を一歩ずつ辿るのがこの勉強会のテーマです。

## 道筋

この資料を貫くのは、次の4つのリフレーミングです。

1. DSL のプログラムは離散的な命令の列として**具象化**できる
2. 具象化されたプログラムは**ステップ実行**に分解できる
3. ステップ実行を Freer で整理すると**限定継続**が浮かび上がる
4. 限定継続は **Generator** の `yield`/`next` に対応する

この4つの軸に沿って、章を構成していきます。

1. **計算の具象化** — CPS で「残りの計算」を明示化し、Defunctionalization でデータに変換する
2. **自由モナドとステップ実行** — 命令を構造化してモナドにし、インタプリタがステップ実行する構造を認識する
3. **Freer と限定継続** — Functor 制約を取り除き、ステップ実行を整理すると限定継続が現れる
4. **Generator と DSL** — 限定継続を TypeScript の Generator で実現し、実用的な DSL を書く

Haskell で理論を確認し、最後に TypeScript で実用的な実装に落とし込みます。補遺として、性能の問題を解決する Codensity モナドを扱います。
